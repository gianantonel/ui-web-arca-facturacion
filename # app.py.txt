# app.py
from __future__ import annotations

from datetime import date, datetime
from uuid import uuid4
import requests
import streamlit as st

from utils import (
    build_payload,
    sanitize_digits,
    is_digits_only,
    validate_required,
    validate_items,
    save_json,
    parse_decimal_optional,  # acepta coma o punto
)

WEBHOOK_URL = "https://n8n.optimizar-ia.com/webhook/06cf93de-06f0-42ac-b859-9424155fa9b7"

IVA_RATE = 0.21

# Listado de opciones de Tipo de Factura según AFIP
TIPO_FACTURA_OPTIONS = ["Factura A", "Factura B", "Factura C"]

# Listado de opciones de Condición frente al IVA según AFIP
IVA_OPTIONS = [
    "IVA Responsable Inscripto",
    "IVA Sujeto Exento",
    "Consumidor Final",
    "Responsable Monotributo",
    "Sujeto No Categorizado",
    "Proveedor del Exterior",
    "Cliente del Exterior",
    "IVA Liberado – Ley N° 19.640",
    "Monotributista Social",
    "IVA No Alcanzado",
    "Monotributo Trabajador Independiente Promovido",
]

# Listado de opciones de Condición de Venta según AFIP
COND_VENTA_OPTIONS = [
    "Contado",
    "Cuenta Corriente",
    "Tarjeta de Débito",
    "Tarjeta de Crédito",
    "Cheque",
    "Ticket / Tiquet",
    "Otros medios de pago electrónico",
    "Transferencia Bancaria",
    "Otra",
]

# Listado de opciones de Servicio/Producto según AFIP
SERVICIO_PRODUCTO_OPTIONS = ["Producto", "Servicio", "Producto/Servicio"]

# Listado de Unidades de Medida según AFIP
UNIDADES_MEDIDA = [
    "Sin descripción",
    "Kilogramo",
    "Metros",
    "Metro cuadrado",
    "Metro cubico",
    "Litros",
    "1000 kilowatt hora",
    "Unidad",
    "Par",
    "Docena",
    "Quilate",
    "Millar",
    "Mega-u. int. act. antib",
    "Unidad int. act. inmung",
    "Gramo",
    "Milimetro",
    "Milimetro cubico",
    "Kilometro",
    "Hectolitro",
    "Mega u. int. act. inmung.",
    "Centímetro",
    "Kilogramo activo",
    "Gramo activo",
    "Gramo base",
    "Uiacthor",
    "Juego o paquete mazo de naipes",
    "Muiacthor",
    "Centimetro cubico",
    "Uiactant",
    "Tonelada",
    "Decametro cubico",
    "Hectometro cubico",
    "Kilometro cubico",
    "Microgramo",
    "Nanogramo",
    "Picogramo",
    "Muiactant",
    "Uiactig",
    "Miligramo",
    "Mililitro",
    "Curie",
    "Milicurie",
    "Microcurie",
    "U. inter. act. hor.",
    "Mega u. inter. act. hor.",
    "Kilogramo base",
    "Gruesa",
    "Muiactig",
    "Kg. bruto",
    "Pack",
    "Horma",
    "Otras unidades",
]


# -----------------------------
# JSON SAFE
# -----------------------------
def _date_to_str(d: date) -> str:
    return d.strftime("%d/%m/%Y")


def make_json_safe(obj):
    """
    Convierte recursivamente objetos no serializables (date/datetime) a string.
    """
    if isinstance(obj, (date, datetime)):
        return _date_to_str(obj.date() if isinstance(obj, datetime) else obj)
    if isinstance(obj, dict):
        return {k: make_json_safe(v) for k, v in obj.items()}
    if isinstance(obj, list):
        return [make_json_safe(v) for v in obj]
    if isinstance(obj, tuple):
        return [make_json_safe(v) for v in obj]
    return obj


# -----------------------------
# STATE
# -----------------------------
def _new_item() -> dict:
    return {
        "uid": str(uuid4()),
        "codigo": "",
        "descripcion": "",
        "cantidad": 1.0,
        "unidad_medida": "Unidad",
        "precio_modo": "con_iva",  # "con_iva" | "sin_iva"
        "precio_unitario": 0.0,
        "descuento_bonificacion": "",
    }


def init_state():
    if "step" not in st.session_state:
        st.session_state["step"] = "edit"  # edit | review | confirmed

    if "facturacion" not in st.session_state:
        today = date.today()
        st.session_state["facturacion"] = {
            "tipo_factura": None,
            "servicio_producto": None,
            "fecha_inicio": today,
            "fecha_fin": today,
            "fecha_vencimiento": today,
        }
    else:
        # asegurar llaves (migración)
        today = date.today()
        st.session_state["facturacion"].setdefault("fecha_inicio", today)
        st.session_state["facturacion"].setdefault("fecha_fin", today)
        st.session_state["facturacion"].setdefault("fecha_vencimiento", today)

    if "emisor" not in st.session_state:
        st.session_state["emisor"] = {
            "razon_social": "",
            "cuit": "",
            "domicilio": "",
            "condicion_iva": None,
            "requiere_delegacion": False,
            "clave_fiscal": "",
        }

    if "receptor" not in st.session_state:
        st.session_state["receptor"] = {
            "razon_social": "",
            "cuit_dni": "",
            "domicilio": "",
            "condicion_iva": None,
            "condicion_venta": None,
        }

    if "items" not in st.session_state:
        st.session_state["items"] = [_new_item()]
    else:
        # migración: asegurar uid en items ya existentes
        fixed = []
        for it in st.session_state["items"]:
            if not isinstance(it, dict):
                continue
            if not it.get("uid"):
                it["uid"] = str(uuid4())
            it.setdefault("precio_modo", "con_iva")
            it.setdefault("precio_unitario", 0.0)
            it.setdefault("cantidad", 1.0)
            it.setdefault("unidad_medida", "Unidad")
            it.setdefault("descuento_bonificacion", "")
            it.setdefault("codigo", "")
            it.setdefault("descripcion", "")
            fixed.append(it)
        if not fixed:
            fixed = [_new_item()]
        st.session_state["items"] = fixed

    st.session_state.setdefault("last_payload", None)
    st.session_state.setdefault("last_saved_path", None)
    st.session_state.setdefault("last_webhook_result", None)


# -----------------------------
# UI HELPERS
# -----------------------------
def fmt_money(value: float) -> str:
    return f"{value:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")


def header():
    st.title("Bienvenido Gabi a tu portal de Facturación automatizada !  by Optimizar-ia ")
    st.subheader("Ingresa los datos de la factura que deseas realizar:")
    st.divider()


def set_digits_field(key_path: str):
    obj_name, field = key_path.split(".")
    obj = st.session_state[obj_name]
    obj[field] = sanitize_digits(obj.get(field, ""))
    st.session_state[obj_name] = obj


def is_factura_con_iva(tipo_factura: str | None) -> bool:
    return tipo_factura in ("Factura A", "Factura B")


# -----------------------------
# CALC
# -----------------------------
def _parse_discount_to_float(d_raw: str) -> float:
    s = str(d_raw or "").strip()
    if s == "":
        return 0.0
    return float(parse_decimal_optional(s))


def compute_item_amounts(item: dict, tipo_factura: str | None) -> tuple[dict, str | None]:
    """
    Factura A/B:
      - si precio_modo=con_iva => precio_unitario es final (con IVA).
      - si precio_modo=sin_iva => precio_unitario es neto, se suma IVA 21%.
    Descuento: MONTO (no %) y se resta del subtotal_total.
    """
    try:
        qty = float(item.get("cantidad", 0) or 0.0)
        price_input = float(item.get("precio_unitario", 0) or 0.0)
        discount = _parse_discount_to_float(item.get("descuento_bonificacion", ""))

        if qty < 0:
            return {}, "Cantidad inválida."
        if price_input < 0:
            return {}, "Precio inválido."

        if is_factura_con_iva(tipo_factura):
            modo = item.get("precio_modo", "con_iva")
            if modo == "sin_iva":
                unit_net = price_input
                unit_gross = unit_net * (1.0 + IVA_RATE)
            else:
                unit_gross = price_input
                unit_net = unit_gross / (1.0 + IVA_RATE)

            unit_iva = unit_gross - unit_net

            subtotal_gross = qty * unit_gross - discount
            subtotal_net = subtotal_gross / (1.0 + IVA_RATE)
            subtotal_iva = subtotal_gross - subtotal_net

            return {
                "unit_net": unit_net,
                "unit_iva": unit_iva,
                "unit_gross": unit_gross,
                "subtotal_net": subtotal_net,
                "subtotal_iva": subtotal_iva,
                "subtotal_gross": subtotal_gross,
            }, None

        # Factura C: sin desglose
        unit_gross = price_input
        subtotal_gross = qty * unit_gross - discount
        return {
            "unit_net": unit_gross,
            "unit_iva": 0.0,
            "unit_gross": unit_gross,
            "subtotal_net": subtotal_gross,
            "subtotal_iva": 0.0,
            "subtotal_gross": subtotal_gross,
        }, None

    except Exception:
        return {}, "No se pudo calcular (revisá cantidad / precio / descuento)."


def compute_totals(items_list: list[dict], tipo_factura: str | None) -> tuple[list[dict], dict, list[str]]:
    per_item_amounts: list[dict] = []
    calc_errors: list[str] = []
    total_net = 0.0
    total_iva = 0.0
    total_gross = 0.0

    for i, it in enumerate(items_list, start=1):
        amounts, err = compute_item_amounts(it, tipo_factura)
        per_item_amounts.append(amounts)
        if err:
            calc_errors.append(f"Item {i}: {err}")
            continue

        total_net += float(amounts.get("subtotal_net", 0.0) or 0.0)
        total_iva += float(amounts.get("subtotal_iva", 0.0) or 0.0)
        total_gross += float(amounts.get("subtotal_gross", 0.0) or 0.0)

    totals = {"total_net": total_net, "total_iva": total_iva, "total_gross": total_gross}
    return per_item_amounts, totals, calc_errors


# -----------------------------
# SECTIONS
# -----------------------------
def render_tipo_

